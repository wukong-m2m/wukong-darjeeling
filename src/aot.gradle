// For AOT benchmarks use -O3 optimisation level. But -Os for everything else
tasks.whenTaskAdded { task ->
    if (task.name.startsWith("compileDarjeelingExecutableDarjeelingBm_")) {
        ext.needToRestoreOs = false
        task.doFirst {
            binaries.all {
                if (cCompiler.args.contains("-Os")) {
                    println "============= SETTING -O3"
                    println cCompiler.args
                    ext.needToRestoreOs = true
                    cCompiler.args.remove "-Os"
                    cCompiler.args "-O3"
                    println cCompiler.args
                }
            }
        }
        task.doLast {
            binaries.all {
                if (ext.needToRestoreOs) {
                    println "============= RESTORING -Os"
                    println cCompiler.args
                    ext.needToRestoreOs = true
                    cCompiler.args.remove "-O3"
                    cCompiler.args "-Os"
                    println cCompiler.args
                }
            }
        }
    }
}

// Each benchmark implements the same interface, so this app can use any.
// But the link in the infusion from the app infusion to the lib infusion is on library name
// so we still need to recompile the app when the benchmark library changes, or we'll
// get a "link not satisfied" panic at run time.
tasks.whenTaskAdded { task ->
    if (task.name == 'infusion_apprtcbench') {
        task.inputs.property("aotbm", project.aotbm)
    }
}

// DEFAULTS
if (!project.hasProperty('aotstrat')) {
    project.ext.aotstrat = 'markloop'
}
if (!project.hasProperty('aotbm')) {
    project.ext.aotbm = 'bsort32'
}
if (!project.hasProperty('aotstackcachesize')) {
    project.ext.aotstackcachesize = '11'
}
if (!project.hasProperty('aotmarkloopregs')) {
    project.ext.aotmarkloopregs = '7'
}
if (!project.hasProperty('aot32bitindex')) {
    project.ext.aot32bitindex = 'false'
}
if (!project.hasProperty('aotconstshiftoptimisation')) {
    project.ext.aotconstshiftoptimisation = 'gcc_like'
} else {
    if (project.ext.aotconstshiftoptimisation != 'none'
     && project.ext.aotconstshiftoptimisation != 'by1'
     && project.ext.aotconstshiftoptimisation != 'all_only_shift'
     && project.ext.aotconstshiftoptimisation != 'all_move_and_shift'
     && project.ext.aotconstshiftoptimisation != 'gcc_like') {
    throw new InvalidUserDataException("Invalid const/shift optimisation:" + project.ext.aotconstshiftoptimisation)        
    }
}

if (project.ext.aotstackcachesize.toInteger() > 11) {
    throw new InvalidUserDataException("Max size for stack cache is 11 words")
}

binaries.all {
    cCompiler.args "-D AOT_STRATEGY_${project.ext.aotstrat.toUpperCase()}"
    cCompiler.args "-D RTC_STACKCACHE_NUMBER_OF_CACHE_REG_PAIRS_TO_USE=${project.ext.aotstackcachesize}"
    cCompiler.args "-D RTC_MARKLOOP_MAX_NUMBER_OF_IDX_TO_PIN=${project.ext.aotmarkloopregs}"

    if (project.ext.aotconstshiftoptimisation == 'by1')
        cCompiler.args "-D AOT_OPTIMISE_CONSTANT_SHIFTS_BY1"
    if (project.ext.aotconstshiftoptimisation == 'all_only_shift')
        cCompiler.args "-D AOT_OPTIMISE_CONSTANT_SHIFTS_ALL_ONLY_SHIFT"
    if (project.ext.aotconstshiftoptimisation == 'all_move_and_shift')
        cCompiler.args "-D AOT_OPTIMISE_CONSTANT_SHIFTS_ALL_MOVE_AND_SHIFT"
    if (project.ext.aotconstshiftoptimisation == 'gcc_like')
        cCompiler.args "-D AOT_OPTIMISE_CONSTANT_SHIFTS_GCC_LIKE"

    if (project.ext.aot32bitindex == 'true')
        cCompiler.args "-D ARRAYINDEX_32BIT"
}

def getOutputDirName() {
    def outdirSTRAT='?'
    if (project.ext.aotstrat == 'baseline')
        outdirSTRAT='0BASE'
    if (project.ext.aotstrat == 'improvedpeephole')
        outdirSTRAT='1PEEP'
    if (project.ext.aotstrat == 'simplestackcache')
        outdirSTRAT='2SMPL'
    if (project.ext.aotstrat == 'poppedstackcache')
        outdirSTRAT='3POPD'
    if (project.ext.aotstrat == 'markloop')
        outdirSTRAT='4MARK'

    def outdirCONSTSHIFT='?'
    if (project.ext.aotconstshiftoptimisation == 'none')
        outdirCONSTSHIFT=0
    if (project.ext.aotconstshiftoptimisation == 'by1')
        outdirCONSTSHIFT=1
    if (project.ext.aotconstshiftoptimisation == 'all_only_shift')
        outdirCONSTSHIFT=2
    if (project.ext.aotconstshiftoptimisation == 'all_move_and_shift')
        outdirCONSTSHIFT=3
    if (project.ext.aotconstshiftoptimisation == 'gcc_like')
        outdirCONSTSHIFT=4

    def outdirREGS=sprintf('%02d', project.ext.aotstackcachesize.toInteger())
    def outdirPINNED=project.ext.aotmarkloopregs

    def outdir32bitindex=''
    if (project.ext.aot32bitindex == 'true')
        outdir32bitindex = '_32BITINDEX'


    if (project.ext.aotstrat == 'baseline') {
        return "results_${outdirSTRAT}_R___P__CS${outdirCONSTSHIFT}${outdir32bitindex}"
    } else if (project.ext.aotstrat == 'improvedpeephole') {
        return "results_${outdirSTRAT}_R___P__CS${outdirCONSTSHIFT}${outdir32bitindex}"
    } else if (project.ext.aotstrat == 'simplestackcache') {
        return "results_${outdirSTRAT}_R${outdirREGS}_P__CS${outdirCONSTSHIFT}${outdir32bitindex}"
    } else if (project.ext.aotstrat == 'poppedstackcache') {
        return "results_${outdirSTRAT}_R${outdirREGS}_P__CS${outdirCONSTSHIFT}${outdir32bitindex}"
    } else {
        return "results_${outdirSTRAT}_R${outdirREGS}_P${outdirPINNED}_CS${outdirCONSTSHIFT}${outdir32bitindex}"
    }
}

project.ext.aotTraceResultsDirName = getOutputDirName()
